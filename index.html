<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Web meet</title>
    <script src="js/simplepeer.min.js"></script>
    <!-- https://cdnjs.cloudflare.com/ajax/libs/simple-peer/9.11.1/simplepeer.min.js -->
    <script src="/socket.io/socket.io.js"></script> <!-- https://unpkg.com/konva@9.3.3/konva.min.js -->
    <script src="js/konva.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        .konva-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            /* Above video and label */
            pointer-events: auto;
            /* Catch drawing events */
            cursor: crosshair;
        }

        .video-wrapper .label {
            z-index: 30;
            /* Keep label on top of canvas */
        }

        .disconnected-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 3rem;
            font-weight: bold;
            z-index: 5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="status">ä»»æ„ã®ãƒ«ãƒ¼ãƒ åã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦æ¥ç¶šã—ã¦ãã ã•ã„</div>
    <div id="roomSelectionArea">
        <input type="text" id="roomInput" placeholder="ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›" value="test-room">
        <input type="password" id="passwordInput" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›" value="">
        <button id="btnJoin">ãƒ«ãƒ¼ãƒ ã«å‚åŠ ã—ã¦é–‹å§‹</button>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>ğŸ“·ã‚«ãƒ¡ãƒ©</label>
            <select id="cameraSelect" style="max-width: 200px;"></select>
            <div class="buttons-row">
                <button id="btnToggleVideo">éš ã™</button>
            </div>
        </div>
        <div class="control-group">
            <label>ğŸ¤ãƒã‚¤ã‚¯</label>
            <select id="micSelect" style="max-width: 200px;"></select>
            <div class="meter-container">
                <div id="audioMeter"></div>
            </div>
            <div class="buttons-row">
                <button id="btnToggleAudio">ãƒŸãƒ¥ãƒ¼ãƒˆã™ã‚‹</button>
            </div>
        </div>
        <div class="control-group">
            <label>ğŸ”Šã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼</label>
            <select id="speakerSelect" style="max-width: 200px;"></select>
        </div>
        <div class="control-group">
            <label>â–£è¡¨ç¤ºãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ</label>
            <select id="layoutSelect" style="max-width: 200px;">
                <option value="layout-pip">ç›¸æ‰‹ã‚’æœ€å¤§åŒ–</option>
                <option value="layout-side">å·¦å³</option>
                <option value="layout-stack">ä¸Šä¸‹</option>
            </select>
        </div>
        <div class="control-group">
            <label>ğŸ–Šæç”»</label>
            <div class="buttons-row">
                <button id="btnClear" onclick="clearAllDrawings()">å…¨æ¶ˆå»</button>
            </div>
        </div>
    </div>

    <div id="videoArea" class="layout-pip">
        <div class="video-wrapper local" id="localWrapper">
            <video id="localVideo" autoplay muted playsinline></video>
            <div id="localKonva" class="konva-container"></div>
            <span class="label">ã‚ãªãŸ</span>
        </div>
        <div class="video-wrapper remote" id="remoteWrapper">
            <video id="remoteVideo" autoplay playsinline></video>
            <div id="remoteKonva" class="konva-container"></div>
            <div id="disconnectedMsg" class="disconnected-msg">æœªæ¥ç¶š</div>
            <span class="label">ãƒªãƒ¢ãƒ¼ãƒˆ</span>
        </div>
    </div>


    <script src="js/drawing.js"></script>
    <script>
        const socket = io();
        let peer = null;
        let localStream = null;
        let currentRoomName = '';
        const roomInput = document.getElementById('roomInput');
        const cameraSelect = document.getElementById('cameraSelect');
        const micSelect = document.getElementById('micSelect');
        const speakerSelect = document.getElementById('speakerSelect');
        const audioMeter = document.getElementById('audioMeter');
        const remoteVideo = document.getElementById('remoteVideo');
        const localVideo = document.getElementById('localVideo');
        let audioContext, analyser, microphone;


        // ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§å–å¾—
        async function getDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const currentVideo = cameraSelect.value;
                const currentAudio = micSelect.value;
                const currentSpeaker = speakerSelect.value;

                cameraSelect.innerHTML = '';
                micSelect.innerHTML = '';
                speakerSelect.innerHTML = '';

                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `${device.kind} - ${device.deviceId.slice(0, 5)}...`;
                    if (device.kind === 'videoinput') cameraSelect.appendChild(option);
                    else if (device.kind === 'audioinput') micSelect.appendChild(option);
                    else if (device.kind === 'audiooutput') speakerSelect.appendChild(option);
                });

                if (currentVideo && [...cameraSelect.options].some(o => o.value === currentVideo)) cameraSelect.value = currentVideo;
                if (currentAudio && [...micSelect.options].some(o => o.value === currentAudio)) micSelect.value = currentAudio;
                if (currentSpeaker && [...speakerSelect.options].some(o => o.value === currentSpeaker)) speakerSelect.value = currentSpeaker;
            } catch (e) { console.error("Error enumerating devices", e); }
        }

        // éŸ³å£°ãƒ¬ãƒ™ãƒ«ãƒ¡ãƒ¼ã‚¿ãƒ¼
        function setupAudioMeter(stream) {
            if (audioContext) audioContext.close();
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                function draw() {
                    if (!localStream || !localStream.active) return;
                    requestAnimationFrame(draw);
                    analyser.getByteFrequencyData(dataArray);
                    let sum = 0;
                    for (let i = 0; i < bufferLength; i++) sum += dataArray[i];
                    let average = sum / bufferLength;
                    let height = Math.min(100, average * 3);
                    audioMeter.style.height = height + "%";
                }
                draw();
            } catch (e) { console.error("Audio Context Error", e); }
        }

        // å…±é€šï¼šã‚«ãƒ¡ãƒ©ã®æº–å‚™
        async function prepareMedia() {
            const videoId = cameraSelect.value;
            const audioId = micSelect.value;

            // æ—¢å­˜ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚Šã€ã‹ã¤ãƒ‡ãƒã‚¤ã‚¹IDãŒå¤‰ã‚ã£ã¦ã„ãªã„å ´åˆã¯å†åˆ©ç”¨ã™ã‚‹
            if (localStream && localStream.active) {
                const currentVideoTrack = localStream.getVideoTracks()[0];
                const currentAudioTrack = localStream.getAudioTracks()[0];

                const currentVideoId = currentVideoTrack ? currentVideoTrack.getSettings().deviceId : null;
                const currentAudioId = currentAudioTrack ? currentAudioTrack.getSettings().deviceId : null;

                // é¸æŠã•ã‚ŒãŸIDã¨ç¾åœ¨ã®IDãŒä¸€è‡´ï¼ˆã¾ãŸã¯æŒ‡å®šãªã—ã§æ—¢ã«ãƒˆãƒ©ãƒƒã‚¯ãŒã‚ã‚‹ï¼‰ãªã‚‰å†åˆ©ç”¨
                const videoMatch = !videoId || (currentVideoId === videoId);
                const audioMatch = !audioId || (currentAudioId === audioId);

                if (videoMatch && audioMatch) {
                    console.log("Reusing existing stream");
                    return localStream;
                }
            }

            const constraints = {
                video: videoId ? { deviceId: { exact: videoId }, width: 1920, height: 1080 } : { width: 1920, height: 1080 },
                audio: audioId ? { deviceId: { exact: audioId } } : true
            };

            try {
                let videoSender = null;
                let audioSender = null;

                if (peer && !peer.destroyed && peer._pc) {
                    const senders = peer._pc.getSenders();
                    videoSender = senders.find(s => s.track && s.track.kind === 'video');
                    audioSender = senders.find(s => s.track && s.track.kind === 'audio');
                }

                let isVideoEnabled = true;
                let isAudioEnabled = true;

                if (localStream) {
                    const vTrack = localStream.getVideoTracks()[0];
                    const aTrack = localStream.getAudioTracks()[0];
                    if (vTrack) isVideoEnabled = vTrack.enabled;
                    if (aTrack) isAudioEnabled = aTrack.enabled;

                    localStream.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia(constraints);

                if (stream.getVideoTracks()[0]) stream.getVideoTracks()[0].enabled = isVideoEnabled;
                if (stream.getAudioTracks()[0]) stream.getAudioTracks()[0].enabled = isAudioEnabled;

                localStream = stream;
                document.getElementById('localVideo').srcObject = stream;

                // Important: Trigger redraw when video metadata loads (aspect ratio known)
                document.getElementById('localVideo').onloadedmetadata = () => {
                    redrawAllLayers();
                };

                setupAudioMeter(stream);

                if (peer && !peer.destroyed) {
                    const videoTrack = stream.getVideoTracks()[0];
                    const audioTrack = stream.getAudioTracks()[0];

                    if (videoSender && videoTrack) {
                        videoSender.replaceTrack(videoTrack).catch(e => console.error("Video Replace Error", e));
                    }
                    if (audioSender && audioTrack) {
                        audioSender.replaceTrack(audioTrack).catch(e => console.error("Audio Replace Error", e));
                    }
                }
                return stream;
            } catch (err) {
                console.error(err);
                alert(`Camera Error: ${err.name} - ${err.message}`);
                throw err;
            }
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        cameraSelect.onchange = prepareMedia;
        micSelect.onchange = prepareMedia;
        speakerSelect.onchange = async () => {
            const deviceId = speakerSelect.value;
            if (remoteVideo.setSinkId) {
                try {
                    await remoteVideo.setSinkId(deviceId);
                    console.log(`Audio output set to ${deviceId}`);
                    alert(`ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚’å¤‰æ›´ã—ã¾ã—ãŸ: ${deviceId}`);
                } catch (e) {
                    console.error("Failed to set audio sink", e);
                    alert("ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã®å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                }
            } else {
                console.warn("setSinkId not supported on this browser");
                alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼å‡ºåŠ›ã®å¤‰æ›´ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
            }
        };

        const layoutSelect = document.getElementById('layoutSelect');
        const videoArea = document.getElementById('videoArea');
        layoutSelect.onchange = () => {
            videoArea.className = layoutSelect.value;
            setTimeout(() => {
                redrawAllLayers();
            }, 100);
        };

        document.getElementById('btnToggleAudio').onclick = () => {
            if (localStream) {
                const track = localStream.getAudioTracks()[0];
                if (track) {
                    track.enabled = !track.enabled;
                    document.getElementById('btnToggleAudio').classList.toggle('active', !track.enabled);
                    document.getElementById('btnToggleAudio').innerText = track.enabled ? "ãƒŸãƒ¥ãƒ¼ãƒˆã™ã‚‹" : "ã€ãƒŸãƒ¥ãƒ¼ãƒˆä¸­ã€‘è§£é™¤ã™ã‚‹";
                }
            }
        };

        document.getElementById('btnToggleVideo').onclick = () => {
            if (localStream) {
                const track = localStream.getVideoTracks()[0];
                if (track) {
                    track.enabled = !track.enabled;
                    document.getElementById('btnToggleVideo').classList.toggle('active', !track.enabled);
                    document.getElementById('btnToggleVideo').innerText = track.enabled ? "éš ã™" : "ã€éè¡¨ç¤ºä¸­ã€‘è¦‹ã›ã‚‹";
                }
            }
        };

        // åˆæœŸåŒ–å®Ÿè¡Œ
        window.addEventListener('load', () => {
            initKonva();
        });

        navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then(async s => {
                s.getTracks().forEach(t => t.stop());
                await getDevices();
                prepareMedia();
            })
            .catch(async e => {
                console.warn("Permission denied or error", e);
                await getDevices();
            });

        function createPeer(isInitiator, stream, roomName) {
            const p = new SimplePeer({
                initiator: isInitiator,
                stream: stream,
                trickle: true
            });

            p.on('signal', signal => {
                socket.emit('signal', {
                    room: roomInput.value,
                    signal: signal
                });
            });

            p.on('stream', remoteStream => {
                const rv = document.getElementById('remoteVideo');
                rv.srcObject = remoteStream;
                document.getElementById('status').innerText = `é€šè©±ä¸­ [${roomName}]`;
                document.getElementById('roomSelectionArea').style.display = 'none';
                document.getElementById('disconnectedMsg').style.display = 'none';

                rv.onloadedmetadata = () => {
                    redrawAllLayers();
                };

                const speakerId = speakerSelect.value;
                if (speakerId && rv.setSinkId) {
                    rv.setSinkId(speakerId).catch(console.error);
                }
            });

            p.on('data', data => {
                try {
                    const json = JSON.parse(data);
                    if (json.type === 'draw') {
                        handleDrawData(json);
                    }
                } catch (e) {
                    console.error("Data channel error", e);
                }
            });

            p.on('close', () => {
                console.log("Peer closed");
                alert("ç›¸æ‰‹ã¨ã®æ¥ç¶šãŒåˆ‡ã‚Œã¾ã—ãŸã€‚å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã€‚");
                location.reload();
            });

            p.on('error', (err) => {
                console.error("Peer error:", err);
                alert("é€šä¿¡ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚å†èª­ã¿è¾¼ã¿ã—ã¾ã™ã€‚");
                location.reload();
            });

            return p;
        }

        document.getElementById('btnJoin').onclick = async () => {
            const roomName = roomInput.value;
            const password = document.getElementById('passwordInput').value;

            if (!roomName) return alert("ãƒ«ãƒ¼ãƒ åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            if (!password) return alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");

            currentRoomName = roomName;

            await prepareMedia();
            socket.emit('join', { roomName, password });
            const statusEl = document.getElementById('status');
            statusEl.innerText = `æ¥ç¶šå‡¦ç†ä¸­...`;
        };

        socket.on('joined', ({ roomName, isNewRoom }) => {
            const statusEl = document.getElementById('status');
            const roomType = isNewRoom ? "æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ" : "æ—¢å­˜ãƒ«ãƒ¼ãƒ ã«å‚åŠ ";
            statusEl.innerText = `ã€${roomType}ã€‘ãƒ«ãƒ¼ãƒ  [${roomName}] ã«å‚åŠ ã—ã¾ã—ãŸã€‚ç›¸æ‰‹ã‚’å¾…æ©Ÿä¸­...`;
            statusEl.style.color = 'lightgreen';
            statusEl.style.fontWeight = 'bold';
        });

        socket.on('auth-error', (message) => {
            console.error('Auth Error:', message);
            const statusEl = document.getElementById('status');
            statusEl.innerText = `èªè¨¼ã‚¨ãƒ©ãƒ¼: ${message}`;
            statusEl.style.color = 'red';
            statusEl.style.fontWeight = 'bold';
            setTimeout(() => alert(`èªè¨¼ã‚¨ãƒ©ãƒ¼: ${message}`), 10);
        });

        socket.on('ready', async () => {
            document.getElementById('status').innerText = 'ç›¸æ‰‹ãŒå‚åŠ ã—ã¾ã—ãŸã€‚æ¥ç¶šã‚’é–‹å§‹ã—ã¾ã™...';
            peer = createPeer(true, localStream, currentRoomName);
        });

        socket.on('signal', async (signalData) => {
            if (!peer) {
                await prepareMedia();
                peer = createPeer(false, localStream, currentRoomName);
            }
            peer.signal(signalData);
        });

    </script>
</body>

</html>